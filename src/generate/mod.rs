use crate::cache::{LayerParams, LayerType, TextureFormat};
use crate::gpu_state::GpuState;
use crate::mapfile::{MapFile, TextureDescriptor};
use crate::srgb::SRGB_TO_LINEAR;
use crate::terrain::dem::DemSource;
use crate::terrain::quadtree::VNode;
use crate::terrain::raster::GlobalRaster;
use crate::terrain::raster::RasterCache;
use crate::{
    asset::{AssetLoadContext, AssetLoadContextBuf, WebAsset},
    cache::LayerMask,
};
use crate::{coordinates, Terrain};
use anyhow::Error;
use bytemuck::Pod;
use cgmath::Vector2;
use futures::future::BoxFuture;
use futures::StreamExt;
use image::{png::PngDecoder, ColorType, ImageDecoder};
use itertools::Itertools;
use maplit::hashmap;
use rayon::prelude::*;
use std::collections::HashSet;
use std::fs;
use std::{
    borrow::Cow, collections::HashMap, f64::consts::PI, fs::File, mem, num::NonZeroU32,
    path::PathBuf,
};
use std::{
    io::{Read, Write},
    path::Path,
    sync::{Arc, Mutex},
};
use vec_map::VecMap;

mod gpu;
pub mod heightmap;

pub(crate) use gpu::*;

/// The radius of the earth in meters.
pub(crate) const EARTH_RADIUS: f64 = 6371000.0;
pub(crate) const EARTH_CIRCUMFERENCE: f64 = 2.0 * PI * EARTH_RADIUS;

pub const BLUE_MARBLE_URLS: [&str; 8] = [
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.A1.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.A2.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.B1.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.B2.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.C1.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.C2.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.D1.png",
    "https://eoimages.gsfc.nasa.gov/images/imagerecords/76000/76487/world.200406.3x21600x21600.D2.png",
];

pub(crate) trait GenerateTile: Send {
    /// Layers generated by this object. Zero means generate cannot operate for nodes of this level.
    fn outputs(&self, level: u8) -> LayerMask;
    /// Layers required to be present at `level` when generating a tile at `level`.
    fn peer_inputs(&self, level: u8) -> LayerMask;
    /// Layers required to be present at `level-1` when generating a tile at `level`.
    fn parent_inputs(&self, level: u8) -> LayerMask;
    /// Returns whether previously generated tiles from this generator are still valid.
    fn needs_refresh(&mut self) -> bool;
    /// Run the generator for `node`.
    fn generate(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        state: &GpuState,
        layers: &VecMap<LayerParams>,
        node: VNode,
        slot: usize,
        parent_slot: Option<usize>,
        output_mask: LayerMask,
    );
}

struct ShaderGen<T, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T> {
    shader: rshader::ShaderSet,
    shader_validation: bool,
    pipeline: Option<wgpu::ComputePipeline>,
    dimensions: u32,
    peer_inputs: LayerMask,
    parent_inputs: LayerMask,
    outputs: LayerMask,
    /// Used instead of outputs for root nodes
    root_outputs: LayerMask,
    /// Used instead of peer_inputs for root nodes
    root_peer_inputs: LayerMask,
    blit_from_bc5_staging: Option<LayerType>,
    name: String,
    f: F,
}
impl<T: Pod, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T> GenerateTile
    for ShaderGen<T, F>
{
    fn outputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.outputs
        } else {
            self.root_outputs
        }
    }
    fn peer_inputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.peer_inputs
        } else {
            self.root_peer_inputs
        }
    }
    fn parent_inputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.parent_inputs
        } else {
            LayerMask::empty()
        }
    }
    fn needs_refresh(&mut self) -> bool {
        if self.shader.refresh() {
            self.pipeline = None;
            true
        } else {
            false
        }
    }
    fn generate(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        state: &GpuState,
        layers: &VecMap<LayerParams>,
        node: VNode,
        slot: usize,
        parent_slot: Option<usize>,
        output_mask: LayerMask,
    ) {
        let uniforms = (self.f)(node, slot, parent_slot, output_mask);

        let uniform_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            size: mem::size_of::<T>() as u64,
            usage: wgpu::BufferUsage::UNIFORM,
            label: Some(&format!("buffer.generate.{}.uniforms", self.name)),
            mapped_at_creation: true,
        });
        let mut buffer_view = uniform_buffer.slice(..).get_mapped_range_mut();
        buffer_view.copy_from_slice(bytemuck::bytes_of(&uniforms));
        drop(buffer_view);
        uniform_buffer.unmap();

        let mut image_views: HashMap<Cow<str>, _> = HashMap::new();
        if let Some(parent_slot) = parent_slot {
            for layer in layers.values() {
                image_views.insert(
                    format!("{}_in", layer.layer_type.name()).into(),
                    state.tile_cache[layer.layer_type].create_view(&wgpu::TextureViewDescriptor {
                        label: Some(&format!("view.{}[{}]", layer.layer_type.name(), parent_slot)),
                        base_array_layer: parent_slot as u32,
                        array_layer_count: Some(NonZeroU32::new(1).unwrap()),
                        ..Default::default()
                    }),
                );
            }
        }

        for layer in
            layers.values().filter(|l| self.outputs(node.level()).contains_layer(l.layer_type))
        {
            image_views.insert(
                format!("{}_out", layer.layer_type.name()).into(),
                state.tile_cache[layer.layer_type].create_view(&wgpu::TextureViewDescriptor {
                    label: Some(&format!("view.{}[{}]", layer.layer_type.name(), slot)),
                    base_array_layer: slot as u32,
                    array_layer_count: Some(NonZeroU32::new(1).unwrap()),
                    ..Default::default()
                }),
            );
        }

        let (bind_group, bind_group_layout) = state.bind_group_for_shader(
            device,
            &self.shader,
            hashmap!["ubo".into() => (false, wgpu::BindingResource::Buffer(wgpu::BufferBinding {
                buffer: &uniform_buffer,
                offset: 0,
                size: None,
            }))],
            image_views,
            &format!("generate.{}", self.name),
        );

        if self.pipeline.is_none() {
            self.pipeline =
                Some(device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    layout: Some(&device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                        bind_group_layouts: [&bind_group_layout][..].into(),
                        push_constant_ranges: &[],
                        label: None,
                    })),
                    module: &device.create_shader_module(&wgpu::ShaderModuleDescriptor {
                        label: Some(&format!("shader.generate.{}", self.name)),
                        source: wgpu::ShaderSource::SpirV(self.shader.compute().into()),
                        flags: if self.shader_validation {
                            wgpu::ShaderFlags::VALIDATION
                        } else {
                            wgpu::ShaderFlags::empty()
                        },
                    }),
                    entry_point: "main",
                    label: Some(&format!("pipeline.generate.{}", self.name)),
                }));
        }

        {
            let mut cpass =
                encoder.begin_compute_pass(&wgpu::ComputePassDescriptor { label: None });
            cpass.set_pipeline(&self.pipeline.as_ref().unwrap());
            cpass.set_bind_group(0, &bind_group, &[]);
            cpass.dispatch(self.dimensions, self.dimensions, 1);
        }

        if let Some(layer) = self.blit_from_bc5_staging {
            let resolution = layers[layer].texture_resolution;
            let resolution_blocks = (resolution + 3) / 4;
            let row_pitch = (resolution_blocks * 16 + 255) & !255;
            assert!(resolution % 4 == 0);
            let buffer = device.create_buffer(&wgpu::BufferDescriptor {
                size: row_pitch as u64 * resolution_blocks as u64,
                usage: wgpu::BufferUsage::COPY_SRC | wgpu::BufferUsage::COPY_DST,
                mapped_at_creation: false,
                label: Some("buffer.blit.bc5"),
            });
            encoder.copy_texture_to_buffer(
                wgpu::ImageCopyTexture {
                    texture: &state.bc5_staging,
                    mip_level: 0,
                    origin: wgpu::Origin3d::default(),
                },
                wgpu::ImageCopyBuffer {
                    buffer: &buffer,
                    layout: wgpu::ImageDataLayout {
                        bytes_per_row: Some(NonZeroU32::new(row_pitch).unwrap()),
                        rows_per_image: None,
                        offset: 0,
                    },
                },
                wgpu::Extent3d {
                    width: resolution_blocks,
                    height: resolution_blocks,
                    depth_or_array_layers: 1,
                },
            );
            encoder.copy_buffer_to_texture(
                wgpu::ImageCopyBuffer {
                    buffer: &buffer,
                    layout: wgpu::ImageDataLayout {
                        bytes_per_row: Some(NonZeroU32::new(row_pitch).unwrap()),
                        rows_per_image: Some(NonZeroU32::new(resolution).unwrap()),
                        offset: 0,
                    },
                },
                wgpu::ImageCopyTexture {
                    texture: &state.tile_cache[LayerType::Normals],
                    mip_level: 0,
                    origin: wgpu::Origin3d { x: 0, y: 0, z: slot as u32 },
                },
                wgpu::Extent3d { width: resolution, height: resolution, depth_or_array_layers: 1 },
            );
        }
    }
}

struct ShaderGenBuilder {
    name: String,
    dimensions: u32,
    shader: rshader::ShaderSource,
    peer_inputs: LayerMask,
    parent_inputs: LayerMask,
    outputs: LayerMask,
    root_outputs: Option<LayerMask>,
    root_peer_inputs: Option<LayerMask>,
    blit_from_bc5_staging: Option<LayerType>,
    shader_validation: bool,
}
impl ShaderGenBuilder {
    fn new(name: String, shader: rshader::ShaderSource) -> Self {
        Self {
            name,
            dimensions: 0,
            outputs: LayerMask::empty(),
            shader,
            peer_inputs: LayerMask::empty(),
            parent_inputs: LayerMask::empty(),
            root_outputs: None,
            root_peer_inputs: None,
            blit_from_bc5_staging: None,
            shader_validation: true,
        }
    }
    fn dimensions(mut self, dimensions: u32) -> Self {
        self.dimensions = dimensions;
        self
    }
    fn outputs(mut self, outputs: LayerMask) -> Self {
        self.outputs = outputs;
        self
    }
    fn root_outputs(mut self, root_outputs: LayerMask) -> Self {
        self.root_outputs = Some(root_outputs);
        self
    }
    fn root_peer_inputs(mut self, root_peer_inputs: LayerMask) -> Self {
        self.root_peer_inputs = Some(root_peer_inputs);
        self
    }
    fn peer_inputs(mut self, peer_inputs: LayerMask) -> Self {
        self.peer_inputs = peer_inputs;
        self
    }
    fn parent_inputs(mut self, parent_inputs: LayerMask) -> Self {
        self.parent_inputs = parent_inputs;
        self
    }
    fn blit_from_bc5_staging(mut self, layer: LayerType) -> Self {
        self.blit_from_bc5_staging = Some(layer);
        self
    }
    fn no_validate(mut self) -> Self {
        self.shader_validation = false;
        self
    }
    fn build<T: Pod, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T>(
        self,
        f: F,
    ) -> Box<dyn GenerateTile> {
        Box::new(ShaderGen {
            name: self.name,
            shader_validation: self.shader_validation,
            shader: rshader::ShaderSet::compute_only(self.shader).unwrap(),
            pipeline: None,
            outputs: self.outputs,
            peer_inputs: self.peer_inputs,
            parent_inputs: self.parent_inputs,
            dimensions: self.dimensions,
            root_outputs: self.root_outputs.unwrap_or(
                if self.parent_inputs == LayerMask::empty() {
                    self.outputs
                } else {
                    LayerMask::empty()
                },
            ),
            root_peer_inputs: self.root_peer_inputs.unwrap_or(self.peer_inputs),
            blit_from_bc5_staging: self.blit_from_bc5_staging,
            f,
        })
    }
}

pub(crate) fn generators(
    layers: &VecMap<LayerParams>,
    soft_float64: bool,
) -> Vec<Box<dyn GenerateTile>> {
    let heightmaps_resolution = layers[LayerType::Heightmaps].texture_resolution;
    let heightmaps_border = layers[LayerType::Heightmaps].texture_border_size;
    let displacements_resolution = layers[LayerType::Displacements].texture_resolution;
    let normals_resolution = layers[LayerType::Normals].texture_resolution;
    let normals_border = layers[LayerType::Normals].texture_border_size;

    vec![
        ShaderGenBuilder::new(
            "heightmaps".into(),
            rshader::shader_source!("../shaders", "gen-heightmaps.comp", "declarations.glsl", "hash.glsl"),
        )
        .outputs(LayerType::Heightmaps.bit_mask())
        .dimensions((heightmaps_resolution + 7) / 8)
        .parent_inputs(LayerType::Heightmaps.bit_mask())
        .no_validate() // validation doesn't support barrier() yet.
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  _|
                  -> GenHeightmapsUniforms {
                let (_parent, parent_index) = node.parent().expect("root node missing");
                let parent_offset = crate::terrain::quadtree::node::OFFSETS[parent_index as usize];
                let origin = [
                    heightmaps_border as i32 / 2,
                    heightmaps_resolution as i32 / 2 - heightmaps_border as i32 / 2,
                ];
                let spacing = node.aprox_side_length()
                    / (heightmaps_resolution - heightmaps_border * 2 - 1) as f32;
                let resolution = heightmaps_resolution - heightmaps_border * 2 - 1;
                let level_resolution = resolution << node.level();
                GenHeightmapsUniforms {
                    position: [
                        (node.x() * resolution) as i32
                            - level_resolution as i32 / 2
                            - heightmaps_border as i32,
                        (node.y() * resolution) as i32
                            - level_resolution as i32 / 2
                            - heightmaps_border as i32,
                    ],
                    origin: [origin[parent_offset.x as usize], origin[parent_offset.y as usize]],
                    spacing,
                    in_slot: parent_slot.unwrap() as i32,
                    out_slot: slot as i32,
                    level_resolution: level_resolution as i32,
                    face: node.face() as u32,
                }
            },
        ),
        ShaderGenBuilder::new(
            "displacements".into(),
            if soft_float64 {
                rshader::shader_source!(
                    "../shaders",
                    "declarations.glsl",
                    "softdouble.glsl",
                    "gen-displacements.comp";
                    "SOFT_DOUBLE" = "1"
                )
            } else {
                rshader::shader_source!("../shaders", "gen-displacements.comp", "declarations.glsl"; "SOFT_DOUBLE" = "0")
            },
        )
        .outputs(LayerType::Displacements.bit_mask())
        .root_outputs(LayerType::Displacements.bit_mask())
        .dimensions((displacements_resolution + 7) / 8)
        .parent_inputs(LayerType::Heightmaps.bit_mask())
        .root_peer_inputs(LayerType::Heightmaps.bit_mask())
        .no_validate() // shaderFloat64 causes validation errors
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  _|
                  -> GenDisplacementsUniforms {
                let base_stride = (heightmaps_resolution - heightmaps_border * 2 - 1)
                    / (displacements_resolution - 1);
                let (offset, stride) = match parent_slot {
                    Some(_) => (Vector2::new(node.x() & 1, node.y() & 1), base_stride / 2),
                    None => (Vector2::new(0, 0), base_stride),
                };
                let world_center = node.center_wspace();
                let resolution = displacements_resolution - 1;
                let level_resolution = resolution << node.level();
                GenDisplacementsUniforms {
                    node_center: world_center.into(),
                    origin: [
                        (heightmaps_border
                            + (heightmaps_resolution - heightmaps_border * 2 - 1) * offset.x / 2)
                            as i32,
                        (heightmaps_border
                            + (heightmaps_resolution - heightmaps_border * 2 - 1) * offset.y / 2)
                            as i32,
                    ],
                    stride: stride as i32,
                    displacements_slot: slot as i32,
                    heightmaps_slot: parent_slot.unwrap_or(slot) as i32,
                    position: [
                        (node.x() * resolution) as i32 - level_resolution as i32 / 2,
                        (node.y() * resolution) as i32 - level_resolution as i32 / 2,
                    ],
                    face: node.face() as i32,
                    level_resolution,
                    padding0: 0.0,
                }
            },
        ),
        ShaderGenBuilder::new(
            "root-normals".into(),
            rshader::shader_source!("../shaders", "gen-root-normals.comp", "declarations.glsl", "hash.glsl"),
        )
        .root_outputs(LayerType::Normals.bit_mask())
        .dimensions((normals_resolution + 3) / 4)
        .peer_inputs(LayerType::Heightmaps.bit_mask())
        .blit_from_bc5_staging(LayerType::Normals)
        .no_validate() // validation doesn't support barrier() yet.
        .build(move |node: VNode, slot: usize, _, _| -> GenNormalsUniforms {
            let spacing =
                node.aprox_side_length() / (normals_resolution - normals_border * 2) as f32;

            GenNormalsUniforms {
                heightmaps_origin: [
                    (heightmaps_border - normals_border) as i32,
                    (heightmaps_border - normals_border) as i32,
                ],
                spacing,
                heightmaps_slot: slot as i32,
                normals_slot: slot as i32,
                padding: [0.0; 3],
            }
        }),
        ShaderGenBuilder::new(
            "materials".into(),
            rshader::shader_source!("../shaders", "gen-materials.comp", "declarations.glsl", "hash.glsl"),
        )
        .outputs(LayerType::Normals.bit_mask() | LayerType::Albedo.bit_mask())
        .dimensions((normals_resolution + 3) / 4)
        .parent_inputs(LayerType::Albedo.bit_mask())
        .peer_inputs(LayerType::Heightmaps.bit_mask())
        .blit_from_bc5_staging(LayerType::Normals)
        .no_validate() // validation doesn't support barrier() yet.
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  output_mask: LayerMask|
                  -> GenMaterialsUniforms {
                let spacing =
                    node.aprox_side_length() / (normals_resolution - normals_border * 2) as f32;

                let albedo_slot =
                    if output_mask.contains_layer(LayerType::Albedo) { slot as i32 } else { -1 };

                let parent_index = node.parent().unwrap().1;

                GenMaterialsUniforms {
                    heightmaps_origin: [
                        (heightmaps_border - normals_border) as i32,
                        (heightmaps_border - normals_border) as i32,
                    ],
                    spacing,
                    heightmaps_slot: slot as i32,
                    normals_slot: slot as i32,
                    albedo_slot,
                    parent_slot: parent_slot.map(|s| s as i32).unwrap_or(-1),
                    parent_origin: [
                        if parent_index % 2 == 0 {
                            normals_border / 2
                        } else {
                            (normals_resolution - normals_border) / 2
                        },
                        if parent_index / 2 == 0 {
                            normals_border / 2
                        } else {
                            (normals_resolution - normals_border) / 2
                        },
                    ],
                    padding: 0,
                }
            },
        ),
    ]
}

pub(crate) struct MapFileBuilder(MapFile);
impl MapFileBuilder {
    pub(crate) fn new() -> Self {
        let layers: VecMap<LayerParams> = hashmap![
            LayerType::Heightmaps.index() => LayerParams {
                    layer_type: LayerType::Heightmaps,
                    texture_resolution: 521,
                    texture_border_size: 4,
                    texture_format: TextureFormat::R32F,
                    tiles_generated_per_frame: 16,
                    // peer_dependency_mask: 0,
                    // parent_dependency_mask: LayerType::Heightmaps.bit_mask(),
                },
            LayerType::Displacements.index() => LayerParams {
                    layer_type: LayerType::Displacements,
                    texture_resolution: 65,
                    texture_border_size: 0,
                    texture_format: TextureFormat::RGBA32F,
                    tiles_generated_per_frame: 128,
                    // peer_dependency_mask: 0,
                    // parent_dependency_mask: LayerType::Heightmaps.bit_mask(),
                },
            LayerType::Albedo.index() => LayerParams {
                    layer_type: LayerType::Albedo,
                    texture_resolution: 516,
                    texture_border_size: 2,
                    texture_format: TextureFormat::RGBA8,
                    tiles_generated_per_frame: 16,
                    // peer_dependency_mask: 0,
                    // parent_dependency_mask: LayerType::Albedo.bit_mask(),
                },
            LayerType::Roughness.index() => LayerParams {
                    layer_type: LayerType::Roughness,
                    texture_resolution: 516,
                    texture_border_size: 2,
                    texture_format: TextureFormat::BC4,
                    tiles_generated_per_frame: 16,
                    // peer_dependency_mask: 0,
                    // parent_dependency_mask: LayerType::Roughness.bit_mask(),
                },
            LayerType::Normals.index() => LayerParams {
                    layer_type: LayerType::Normals,
                    texture_resolution: 516,
                    texture_border_size: 2,
                    texture_format: TextureFormat::BC5,
                    tiles_generated_per_frame: 16,
                    // peer_dependency_mask: LayerType::Heightmaps.bit_mask(),
                    // parent_dependency_mask: LayerType::Albedo.bit_mask(),
                },
        ]
        .into_iter()
        .collect();

        let mapfile = MapFile::new(layers);
        VNode::breadth_first(|n| {
            mapfile.reload_tile_state(LayerType::Heightmaps, n, true).unwrap();
            n.level() < VNode::LEVEL_CELL_153M
        });
        VNode::breadth_first(|n| {
            mapfile.reload_tile_state(LayerType::Albedo, n, true).unwrap();
            n.level() < VNode::LEVEL_CELL_625M
        });
        VNode::breadth_first(|n| {
            mapfile.reload_tile_state(LayerType::Roughness, n, true).unwrap();
            false
        });

        Self(mapfile)
    }

    /// Actually construct the `QuadTree`.
    ///
    /// This function will (the first time it is called) download many gigabytes of raw data,
    /// primarily datasets relating to real world land cover and elevation. These files will be
    /// stored in ~/.cache/terra, so that they don't have to be fetched multiple times. This means that
    /// this function can largely resume from where it left off if interrupted.
    ///
    /// Even once all needed files have been downloaded, the generation process takes a large amount
    /// of CPU resources. You can expect it to run at full load continiously for several full
    /// minutes, even in release builds (you *really* don't want to wait for generation in debug
    /// mode...).
    pub(crate) async fn build(mut self) -> Result<MapFile, Error> {
        let mut context = AssetLoadContextBuf::new();
        let mut context = context.context("Building Terrain...", 1);
        // generate_heightmaps(&mut mapfile, &mut context).await?;
        // generate_albedo(&mut mapfile, &mut context)?;
        // generate_roughness(&mut mapfile, &mut context)?;
        generate_noise(&mut self.0, &mut context)?;
        generate_sky(&mut self.0, &mut context)?;

        Ok(self.0)
    }
}

impl Terrain {
    /// Generate heightmap tiles.
    ///
    /// `etopo1_file` is the location of [ETOPO1_Ice_c_geotiff.zip](https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/cell_registered/georeferenced_tiff/ETOPO1_Ice_c_geotiff.zip).
    pub async fn generate_heightmaps<'a, F: FnMut(&str, usize, usize) + Send>(
        &mut self,
        etopo1_file: impl AsRef<Path>,
        nasadem_directory: PathBuf,
        nasadem_reprojected_directory: PathBuf,
        mut progress_callback: F,
    ) -> Result<(), Error> {
        let (missing_tiles, _total_tiles) =
            self.mapfile.get_missing_base(LayerType::Heightmaps)?;
        if missing_tiles.is_empty() {
            return Ok(());
        }

        let base_level = VNode::LEVEL_CELL_38M;
        let sector_size = 8;

        let layer = &self.mapfile.layers()[LayerType::Heightmaps];
        let resolution = layer.texture_resolution as usize;
        let border_size = layer.texture_border_size as usize;

        assert_eq!((resolution - 1) % sector_size, 0);

        fs::create_dir_all(&nasadem_reprojected_directory)?;
        let (missing_sectors, total_sectors) = {
            let mut existing_sectors = HashSet::new();

            for entry in fs::read_dir(&nasadem_reprojected_directory)? {
                if let Ok(s) = entry?.file_name().into_string() {
                    existing_sectors.insert(s);
                }
            }

            let mut missing_sectors = Vec::new();
            let mut total_sectors = 0;
            for root_node in VNode::roots() {
                for x in 0..(resolution / sector_size) {
                    for y in 0..(resolution / sector_size) {
                        total_sectors += 1;
                        if !existing_sectors.contains(&format!(
                            "nasadem_S{}-{}x{}.raw",
                            root_node.face(),
                            x,
                            y
                        )) {
                            missing_sectors.push((root_node, x, y));
                        }
                    }
                }
            }
            (missing_sectors, total_sectors)
        };

        if !missing_sectors.is_empty() {
            let mut gen = heightmap::HeightmapGen {
                resolution: (sector_size << base_level) + 1,
                root_resolution: ((resolution - 1) << base_level) + 1,
                root_border_size: border_size << base_level,
                dems: RasterCache::new(Arc::new(DemSource::Nasadem(nasadem_directory)), 64),
                global_dem: Arc::new(crate::terrain::dem::parse_etopo1(
                    etopo1_file,
                    &mut progress_callback,
                )?),
            };

            const MAX_CONCURRENT: usize = 32;
            const MAX_RASTERS: usize = 256;

            let mut sectors_processed = total_sectors - missing_sectors.len();
            let mut missing = missing_sectors.into_iter().peekable();
            let mut pending = futures::stream::FuturesUnordered::new();

            let mut loaded_rasters = 0;
            let mut unstarted: Option<(usize, BoxFuture<_>)> = None;

            loop {
                progress_callback(
                    "Generating heightmaps...",
                    sectors_processed,
                    total_sectors,
                );
                if unstarted.is_some()
                    && (loaded_rasters + unstarted.as_ref().unwrap().0 <= MAX_RASTERS
                        || loaded_rasters == 0)
                {
                    let (num_rasters, future) = unstarted.take().unwrap();
                    loaded_rasters += num_rasters;
                    pending.push(future);
                } else if unstarted.is_none() && pending.len() < MAX_CONCURRENT && missing.peek().is_some() {
                    let (root_node, x, y) = missing.next().unwrap();
                    unstarted = Some(gen.generate_sector(
                        root_node,
                        x,
                        y,
                        nasadem_reprojected_directory.join(&format!(
                            "nasadem_S{}-{}x{}.raw",
                            root_node.face(),
                            x,
                            y
                        )),
                    ));
                } else {
                    match pending.next().await {
                        Some(result) => {
                            loaded_rasters -= result?;
                            sectors_processed += 1;
                        }
                        None => break,
                    }
                }
            }
        }

        // let total_missing = missing.len();
        // let mut missing_by_level = VecMap::new();
        // for m in missing {
        //     missing_by_level.entry(m.level().into()).or_insert(Vec::new()).push(m);
        // }

        Ok(())
    }

    /// Generate albedo tiles.
    ///
    /// `blue_marble_directory` must contain the 8 files from NASA's Blue Marble: Next Generation
    /// indicated in [`BLUE_MARBLE_URLS`](constant.BLUE_MARBLE_URLS.html).
    pub async fn generate_albedos<F: FnMut(&str, usize, usize) + Send>(
        &mut self,
        blue_marble_directory: impl AsRef<Path>,
        mut progress_callback: F,
    ) -> Result<(), Error> {
        let (missing, total_tiles) = self.mapfile.get_missing_base(LayerType::Albedo)?;
        if missing.is_empty() {
            return Ok(());
        }

        let layer = self.mapfile.layers()[LayerType::Albedo].clone();
        assert!(layer.texture_border_size >= 2);

        let bm_dimensions = 21600;
        let mut values = vec![0u8; bm_dimensions * bm_dimensions * 8 * 3];

        let (north, south) = values.split_at_mut(bm_dimensions * bm_dimensions * 12);
        let mut slices: Vec<&mut [u8]> = north
            .chunks_exact_mut(bm_dimensions * 3)
            .interleave(south.chunks_exact_mut(bm_dimensions * 3))
            .collect();

        let mut decoders = Vec::new();
        for x in 0..4 {
            for y in 0..2 {
                let decoder =
                    PngDecoder::new(File::open(blue_marble_directory.as_ref().join(format!(
                        "world.200406.3x21600x21600.{}{}.png",
                        "ABCD".chars().nth(x).unwrap(),
                        "12".chars().nth(y).unwrap()
                    )))?)?;
                assert_eq!(decoder.dimensions(), (bm_dimensions as u32, bm_dimensions as u32));
                assert_eq!(decoder.color_type(), ColorType::Rgb8);
                decoders.push(decoder.into_reader()?);
            }
        }

        let total = slices.len() / 8;
        for (i, chunk) in slices.chunks_mut(8).enumerate() {
            if i % 108 == 0 {
                progress_callback("Loading blue marble images... ", i / 108, total / 108);
            }

            decoders.par_iter_mut().zip(chunk).try_for_each(|(d, s)| d.read_exact(s))?;
        }

        let bluemarble =
            GlobalRaster { width: bm_dimensions * 4, height: bm_dimensions * 2, bands: 3, values };

        let mapfile = &self.mapfile;
        let progress = &Mutex::new((total_tiles - missing.len(), progress_callback));

        missing.into_par_iter().try_for_each(|n| -> Result<(), Error> {
            {
                let mut progress = progress.lock().unwrap();
                let v = progress.0;
                progress.1("Generating albedo... ", v, total_tiles);
                progress.0 += 1;
            }

            let mut colormap = Vec::with_capacity(
                layer.texture_resolution as usize * layer.texture_resolution as usize,
            );

            let coordinates: Vec<_> = (0..(layer.texture_resolution * layer.texture_resolution))
                .into_par_iter()
                .map(|i| {
                    let cspace = n.cell_position_cspace(
                        (i % layer.texture_resolution) as i32,
                        (i / layer.texture_resolution) as i32,
                        layer.texture_border_size as u16,
                        layer.texture_resolution as u16,
                    );
                    let polar = coordinates::cspace_to_polar(cspace);
                    (polar.x.to_degrees(), polar.y.to_degrees())
                })
                .collect();

            for (lat, long) in coordinates {
                colormap.extend_from_slice(&[
                    SRGB_TO_LINEAR[bluemarble.interpolate(lat, long, 0) as u8],
                    SRGB_TO_LINEAR[bluemarble.interpolate(lat, long, 1) as u8],
                    SRGB_TO_LINEAR[bluemarble.interpolate(lat, long, 2) as u8],
                    255,
                ]);
            }

            let mut data = Vec::new();
            let encoder = image::codecs::png::PngEncoder::new(&mut data);
            encoder.encode(
                &colormap,
                layer.texture_resolution as u32,
                layer.texture_resolution as u32,
                image::ColorType::Rgba8,
            )?;
            mapfile.write_tile(LayerType::Albedo, n, &data, true)
        })
    }

    pub async fn generate_roughness<F: FnMut(&str, usize, usize) + Send>(
        &mut self,
        mut progress_callback: F,
    ) -> Result<(), Error> {
        let (missing, total_tiles) = self.mapfile.get_missing_base(LayerType::Roughness)?;
        if missing.is_empty() {
            return Ok(());
        }

        let layer = self.mapfile.layers()[LayerType::Roughness].clone();
        assert!(layer.texture_border_size >= 2);
        assert_eq!(layer.texture_resolution % 4, 0);

        let total_missing = missing.len();
        for (i, n) in missing.into_iter().enumerate() {
            progress_callback(
                "Generating roughness... ",
                i + (total_tiles - total_missing),
                total_tiles,
            );

            let mut data = Vec::with_capacity(
                layer.texture_resolution as usize * layer.texture_resolution as usize / 2,
            );
            for _ in 0..(layer.texture_resolution / 4) {
                for _ in 0..(layer.texture_resolution / 4) {
                    data.extend_from_slice(&[179, 180, 0, 0, 0, 0, 0, 0]);
                }
            }

            let mut e = lz4::EncoderBuilder::new().level(9).build(Vec::new())?;
            e.write_all(&data)?;

            self.mapfile.write_tile(LayerType::Roughness, n, &e.finish().0, true)?;
        }

        Ok(())
    }
}

fn generate_noise(mapfile: &mut MapFile, context: &mut AssetLoadContext) -> Result<(), Error> {
    if !mapfile.reload_texture("noise") {
        // wavelength = 1.0 / 256.0;
        let noise_desc = TextureDescriptor {
            width: 2048,
            height: 2048,
            depth: 1,
            format: TextureFormat::RGBA8,
            bytes: 4 * 2048 * 2048,
        };

        let noise_heightmaps: Vec<_> =
            (0..4).map(|i| crate::terrain::heightmap::wavelet_noise(64 << i, 32 >> i)).collect();

        context.reset("Generating noise textures... ", noise_heightmaps.len());

        let len = noise_heightmaps[0].heights.len();
        let mut heights = vec![0u8; len * 4];
        for (i, heightmap) in noise_heightmaps.into_iter().enumerate() {
            context.set_progress(i as u64);
            let mut dist: Vec<(usize, f32)> = heightmap.heights.into_iter().enumerate().collect();
            dist.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
            for j in 0..len {
                heights[dist[j].0 * 4 + i] = (j * 256 / len) as u8;
            }
        }

        mapfile.write_texture("noise", noise_desc, &heights[..])?;
    }
    Ok(())
}

fn generate_sky(mapfile: &mut MapFile, context: &mut AssetLoadContext) -> Result<(), Error> {
    if !mapfile.reload_texture("sky") {
        context.reset("Generating sky texture... ", 1);
        let sky = WebTextureAsset {
            url: "https://www.eso.org/public/archives/images/original/eso0932a.tif".to_owned(),
            filename: "eso0932a.tif".to_owned(),
        }
        .load(context)?;
        mapfile.write_texture("sky", sky.0, &sky.1)?;
    }
    if !mapfile.reload_texture("transmittance") || !mapfile.reload_texture("inscattering") {
        let atmosphere = crate::sky::Atmosphere::new(context)?;
        mapfile.write_texture(
            "transmittance",
            TextureDescriptor {
                width: atmosphere.transmittance.size[0] as u32,
                height: atmosphere.transmittance.size[1] as u32,
                depth: 1,
                format: TextureFormat::RGBA32F,
                bytes: atmosphere.transmittance.data.len() * 4,
            },
            bytemuck::cast_slice(&atmosphere.transmittance.data),
        )?;
        mapfile.write_texture(
            "inscattering",
            TextureDescriptor {
                width: atmosphere.inscattering.size[0] as u32,
                height: atmosphere.inscattering.size[1] as u32,
                depth: atmosphere.inscattering.size[2] as u32,
                format: TextureFormat::RGBA32F,
                bytes: atmosphere.inscattering.data.len() * 4,
            },
            bytemuck::cast_slice(&atmosphere.inscattering.data),
        )?;
    }
    Ok(())
}

struct WebTextureAsset {
    url: String,
    filename: String,
}
impl WebAsset for WebTextureAsset {
    type Type = (TextureDescriptor, Vec<u8>);

    fn url(&self) -> String {
        self.url.clone()
    }
    fn filename(&self) -> String {
        self.filename.clone()
    }
    fn parse(&self, _context: &mut AssetLoadContext, data: Vec<u8>) -> Result<Self::Type, Error> {
        // TODO: handle other pixel formats
        let img = image::load_from_memory(&data)?.into_rgba8();
        Ok((
            TextureDescriptor {
                format: TextureFormat::RGBA8,
                width: img.width(),
                height: img.height(),
                depth: 1,
                bytes: (*img).len(),
            },
            img.into_raw(),
        ))
    }
}
